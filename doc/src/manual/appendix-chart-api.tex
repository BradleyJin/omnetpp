\appendixchapter{Python API for Chart Scripts}
\label{cha:chart-api}

This chapter describes the API of the Python modules available
for chart scripts. These modules are available in the Analysis Tool
in the IDE, in \fprog{opp\_charttool}, and may also be used
in standalone Python scripts.

Some conventional import aliases appear in code fragments throughout this
chapter, such as \ttt{np} for NumPy and \ttt{pd} for Pandas.

\section{Modules}
\label{cha:chart-api:modules}

% --------
% The rest of this file is the output of the tools/extract_chart_api.py
% script (tools/chartapi.txt), pasted here manually, do not edit here!
% --------


%
% generated with extract_chart_api.py
%

\subsection{Module omnetpp.scave.results}
\label{cha:chart-api:omnetpp.scave.results}

\par This module lets the scripts that power the charts in the IDE query
any simulation results and metadata referenced by the .anf file they
are in, returned as as Pandas DataFrames in various formats.

\par The \ttt{filter\_expressions} parameter in all functions has the same syntax.
It is always evaluated independently on every loaded result item or metadata entry, and its value
determines whether the given item or piece of metadata is included in the returned \ttt{DataFrame}.

\subsubsection{get\_serial()}
\label{cha:chart-api:omnetpp.scave.results:get-serial}

\begin{flushleft}
\ttt{get\_serial()}
\end{flushleft}

\par Returns an integer that is incremented every time the set of loaded results
change, typically as a result of the IDE loading, reloading or unloading
a scalar or vector result file. The serial can be used for invalidating
cached intermediate results when their input changes.

\subsubsection{get\_results()}
\label{cha:chart-api:omnetpp.scave.results:get-results}

\begin{flushleft}
\ttt{get\_results(filter\_expression="", row\_types=["runattr", "itervar", "config", "scalar", "vector", "statistic", "histogram", "param", "attr"], omit\_unused\_columns=True, include\_fields\_as\_scalars=False, start\_time=-inf, end\_time=inf)}
\end{flushleft}

\par Returns a filtered set of results and metadata in CSV-like format.
The items can be any type, even mixed together in a single \ttt{DataFrame}.
They are selected from the complete set of data referenced by the analysis file (\ttt{.anf}),
including only those for which the given \ttt{filter\_expression} evaluates to \ttt{True}.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired items. Example: \ttt{module ={\textasciitilde} "*host*" AND name ={\textasciitilde} "numPacket*"}
  \item \ttt{row\_types}: Optional. When given, filters the returned rows by type. Should be a unique list, containing any number of these strings:
\ttt{"runattr"}, \ttt{"itervar"}, \ttt{"config"}, \ttt{"scalar"}, \ttt{"vector"}, \ttt{"statistic"}, \ttt{"histogram"}, \ttt{"param"}, \ttt{"attr"}
  \item \ttt{omit\_unused\_columns} \textit{(bool)}: Optional. If \ttt{True}, all columns that would only contain \ttt{None} are removed from the returned DataFrame
  \item \ttt{include\_fields\_as\_scalars} \textit{(bool)}: Optional. If \ttt{True}, the fields of statistics and histograms (\ttt{:min}, \ttt{:mean}, etc.) are also
returned as synthetic scalars.
  \item \ttt{start\_time}, \ttt{end\_time} \textit{(double)}: Optional time limits to trim the data of vector type results.
The unit is seconds, both the \ttt{vectime} and \ttt{vecvalue} arrays will be affected, the interval is left-closed, right-open.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}:  Identifies the simulation run
  \item \ttt{type} \textit{(string)}: Row type, one of the following: scalar, vector, statistics, histogram, runattr, itervar, param, attr
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: Name of the result item (scalar, statistic, histogram or vector)
  \item \ttt{attrname} \textit{(string)}: Name of the run attribute or result item attribute (in the latter case, the module and name columns identify the result item the attribute belongs to)
  \item \ttt{attrvalue} \textit{(string)}: Value of run and result item attributes, iteration variables, saved ini param settings (runattr, attr, itervar, param)
  \item \ttt{value} \textit{(double or string)}: Output scalar or parameter value
  \item \ttt{count}, \ttt{sumweights}, \ttt{mean}, \ttt{min}, \ttt{max}, \ttt{stddev} \textit{(double)}: Fields of the statistics or histogram
  \item \ttt{binedges}, \ttt{binvalues} \textit{(np.array)}: Histogram bin edges and bin values, as space-separated lists. \ttt{len(binedges)==len(binvalues)+1}
  \item \ttt{underflows}, \ttt{overflows} \textit{(double)}: Sum of weights (or counts) of underflown and overflown samples of histograms
  \item \ttt{vectime}, \ttt{vecvalue} \textit{(np.array)}: Output vector time and value arrays, as space-separated lists

\end{itemize}

\subsubsection{get\_runs()}
\label{cha:chart-api:omnetpp.scave.results:get-runs}

\begin{flushleft}
\ttt{get\_runs(filter\_expression="", include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False)}
\end{flushleft}

\par Returns a filtered list of runs, identified by their run ID.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression}: The filter expression to select the desired runs.
Example: \ttt{runattr:network ={\textasciitilde} "Aloha" AND config:Aloha.slotTime ={\textasciitilde} 0}
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the result, pivoted into columns.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item Additional metadata items (run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_runattrs()}
\label{cha:chart-api:omnetpp.scave.results:get-runattrs}

\begin{flushleft}
\ttt{get\_runattrs(filter\_expression="", include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False)}
\end{flushleft}

\par Returns a filtered list of run attributes.

\par The set of run attributes is fixed: \ttt{configname}, \ttt{datetime}, \ttt{experiment},
\ttt{inifile}, \ttt{iterationvars}, \ttt{iterationvarsf}, \ttt{measurement}, \ttt{network},
\ttt{processid}, \ttt{repetition}, \ttt{replication}, \ttt{resultdir}, \ttt{runnumber}, \ttt{seedset}.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression}: The filter expression to select the desired run attributes.
Example: \ttt{name ={\textasciitilde} *date* AND config:Aloha.slotTime ={\textasciitilde} 0}
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the result, pivoted into columns.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{name} \textit{(string)}: The name of the run attribute
  \item \ttt{value} \textit{(string)}: The value of the run attribue
  \item Additional metadata items (run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_itervars()}
\label{cha:chart-api:omnetpp.scave.results:get-itervars}

\begin{flushleft}
\ttt{get\_itervars(filter\_expression="", include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False)}
\end{flushleft}

\par Returns a filtered list of iteration variables.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired iteration variables.
Example: \ttt{name ={\textasciitilde} iaMean AND config:Aloha.slotTime ={\textasciitilde} 0}
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the result, pivoted into columns.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{name} \textit{(string)}: The name of the iteration variable
  \item \ttt{value} \textit{(string)}: The value of the iteration variable.
  \item Additional metadata items (run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_scalars()}
\label{cha:chart-api:omnetpp.scave.results:get-scalars}

\begin{flushleft}
\ttt{get\_scalars(filter\_expression="", include\_attrs=False, include\_fields=False, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False, merge\_module\_and\_name=False)}
\end{flushleft}

\par Returns a filtered list of scalar results.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired scalars.
Example: \ttt{name ={\textasciitilde} "channelUtilization*" AND runattr:replication ={\textasciitilde} "\#0"}
  \item \ttt{include\_attrs} \textit{(bool)}: Optional. When set to \ttt{True}, result attributes (like \ttt{unit}
or \ttt{source} for example) are appended to the DataFrame, pivoted into columns.
  \item \ttt{include\_fields} \textit{(bool)}: Optional. If \ttt{True}, the fields of statistics and histograms
(\ttt{:min}, \ttt{:mean}, etc.) are also returned as synthetic scalars.
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the DataFrame, pivoted into columns.
  \item \ttt{merge\_module\_and\_name} \textit{(bool)}: Optional. When set to \ttt{True}, the value in the \ttt{module} column
is prepended to the value in the \ttt{name} column, joined by a period, in every row.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: The name of the scalar
  \item \ttt{value} \textit{(double)}: The value of the scalar
  \item Additional metadata items (result attributes, run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_parameters()}
\label{cha:chart-api:omnetpp.scave.results:get-parameters}

\begin{flushleft}
\ttt{get\_parameters(filter\_expression="", include\_attrs=False, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False, merge\_module\_and\_name=False)}
\end{flushleft}

\par Returns a filtered list of parameters - actually computed values of individual \ttt{cPar} instances in the fully built network.

\par Parameters are considered "pseudo-results", similar to scalars - except their values are strings. Even though they act
mostly as input to the actual simulation run, the actually assigned value of individual \ttt{cPar} instances is valuable information,
as it is the result of the network setup process. For example, even if a parameter is set up as an expression like \ttt{normal(3, 0.4)}
from \ttt{omnetpp.ini}, the returned DataFrame will contain the single concrete value picked for every instance of the parameter.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired parameters.
Example: \ttt{name ={\textasciitilde} "x" AND module ={\textasciitilde} Aloha.server}
  \item \ttt{include\_attrs} \textit{(bool)}: Optional. When set to \ttt{True}, result attributes (like \ttt{unit} for
example) are appended to the DataFrame, pivoted into columns.
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the DataFrame, pivoted into columns.
  \item \ttt{merge\_module\_and\_name} \textit{(bool)}: Optional. When set to \ttt{True}, the value in the \ttt{module} column
is prepended to the value in the \ttt{name} column, joined by a period, in every row.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: The name of the parameter
  \item \ttt{value} \textit{(string)}: The value of the parameter.
  \item Additional metadata items (result attributes, run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_vectors()}
\label{cha:chart-api:omnetpp.scave.results:get-vectors}

\begin{flushleft}
\ttt{get\_vectors(filter\_expression="", include\_attrs=False, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False, merge\_module\_and\_name=False, start\_time=-inf, end\_time=inf)}
\end{flushleft}

\par Returns a filtered list of vector results.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired vectors.
Example: \ttt{name ={\textasciitilde} "radioState*" AND runattr:replication ={\textasciitilde} "\#0"}
  \item \ttt{include\_attrs} \textit{(bool)}: Optional. When set to \ttt{True}, result attributes (like \ttt{unit}
or \ttt{source} for example) are appended to the DataFrame, pivoted into columns.
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the DataFrame, pivoted into columns.
  \item \ttt{merge\_module\_and\_name} \textit{(bool)}: Optional. When set to \ttt{True}, the value in the \ttt{module} column
is prepended to the value in the \ttt{name} column, joined by a period, in every row.
  \item \ttt{start\_time}, \ttt{end\_time} \textit{(double)}: Optional time limits to trim the data of vector type results.
The unit is seconds, both the \ttt{vectime} and \ttt{vecvalue} arrays will be affected, the interval is left-closed, right-open.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: The name of the vector
  \item \ttt{vectime}, \ttt{vecvalue} \textit{(np.array)}: The simulation times and the corresponding values in the vector
  \item Additional metadata items (result attributes, run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_statistics()}
\label{cha:chart-api:omnetpp.scave.results:get-statistics}

\begin{flushleft}
\ttt{get\_statistics(filter\_expression="", include\_attrs=False, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False, merge\_module\_and\_name=False)}
\end{flushleft}

\par Returns a filtered list of statistics results.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired statistics.
Example: \ttt{name ={\textasciitilde} "collisionLength:stat" AND itervar:iaMean ={\textasciitilde} "5"}
  \item \ttt{include\_attrs} \textit{(bool)}: Optional. When set to \ttt{True}, result attributes (like \ttt{unit}
or \ttt{source} for example) are appended to the DataFrame, pivoted into columns.
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the DataFrame, pivoted into columns.
  \item \ttt{merge\_module\_and\_name} \textit{(bool)}: Optional. When set to \ttt{True}, the value in the \ttt{module} column
is prepended to the value in the \ttt{name} column, joined by a period, in every row.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: The name of the vector
  \item \ttt{count}, \ttt{sumweights}, \ttt{mean}, \ttt{stddev}, \ttt{min}, \ttt{max} \textit{(double)}: The characteristic mathematical properties of the statistics result
  \item Additional metadata items (result attributes, run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_histograms()}
\label{cha:chart-api:omnetpp.scave.results:get-histograms}

\begin{flushleft}
\ttt{get\_histograms(filter\_expression="", include\_attrs=False, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False, merge\_module\_and\_name=False)}
\end{flushleft}

\par Returns a filtered list of histogram results.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired histogram.
Example: \ttt{name ={\textasciitilde} "collisionMultiplicity:histogram" AND itervar:iaMean ={\textasciitilde} "2"}
  \item \ttt{include\_attrs} \textit{(bool)}: Optional. When set to \ttt{True}, result attributes (like \ttt{unit}
or \ttt{source} for example) are appended to the DataFrame, pivoted into columns.
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the DataFrame, pivoted into columns.
  \item \ttt{merge\_module\_and\_name} \textit{(bool)}: Optional. When set to \ttt{True}, the value in the \ttt{module} column
is prepended to the value in the \ttt{name} column, joined by a period, in every row.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{module} \textit{(string)}: Hierarchical name (a.k.a. full path) of the module that recorded the result item
  \item \ttt{name} \textit{(string)}: The name of the vector
  \item \ttt{count}, \ttt{sumweights}, \ttt{mean}, \ttt{stddev}, \ttt{min}, \ttt{max} \textit{(double)}: The characteristic mathematical properties of the histogram
  \item \ttt{binedges}, \ttt{binvalues} \textit{(np.array)}: The histogram edge locations and the weighted sum of the collected samples in each bin. \ttt{len(binedges) == len(binvalues) + 1}
  \item \ttt{underflows}, \ttt{overflows} \textit{(double)}: The weighted sum of the samples that fell outside of the histogram bin range in the two directions
  \item Additional metadata items (result attributes, run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_config\_entries()}
\label{cha:chart-api:omnetpp.scave.results:get-config-entries}

\begin{flushleft}
\ttt{get\_config\_entries(filter\_expression, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False)}
\end{flushleft}

\par Returns a filtered list of config entries. That is: parameter assignment patterns; and global and per-object config options.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired config entries.
Example: \ttt{name ={\textasciitilde} sim-time-limit AND itervar:numHosts ={\textasciitilde} 10}
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the result, pivoted into columns.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{name} \textit{(string)}: The name of the config entry
  \item \ttt{value} \textit{(string)}: The value of the config entry
  \item Additional metadata items (run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsubsection{get\_param\_assignments()}
\label{cha:chart-api:omnetpp.scave.results:get-param-assignments}

\begin{flushleft}
\ttt{get\_param\_assignments(filter\_expression, include\_runattrs=False, include\_itervars=False, include\_param\_assignments=False, include\_config\_entries=False)}
\end{flushleft}

\par Returns a filtered list of parameter assignment patterns. The result is a subset of what \ttt{get\_config\_entries}
would return with the same arguments.

\par Parameters:

\begin{itemize}
  \item \ttt{filter\_expression} \textit{(string)}: The filter expression to select the desired parameter assignments.
Example: \ttt{name ={\textasciitilde} **.flowID AND itervar:numHosts ={\textasciitilde} 10}
  \item \ttt{include\_runattrs}, \ttt{include\_itervars}, \ttt{include\_param\_assignments}, \ttt{include\_config\_entries} \textit{(bool)}:
Optional. When set to \ttt{True}, additional pieces of metadata about the run is appended to the result, pivoted into columns.

\end{itemize}


\par Columns of the returned DataFrame:

\begin{itemize}
  \item \ttt{runID} \textit{(string)}: Identifies the simulation run
  \item \ttt{name} \textit{(string)}: The parameter assignment pattern
  \item \ttt{value} \textit{(string)}: The assigned value
  \item Additional metadata items (run attributes, iteration variables, etc.), as requested

\end{itemize}

\subsection{Module omnetpp.scave.chart}
\label{cha:chart-api:omnetpp.scave.chart}

\par This module provides functions to access the properties of the chart object.

\subsubsection{get\_properties()}
\label{cha:chart-api:omnetpp.scave.chart:get-properties}

\begin{flushleft}
\ttt{get\_properties()}
\end{flushleft}

\par Returns the currently set properties of the chart as a \ttt{dict}
whose keys and values are both all strings.

\subsubsection{get\_property()}
\label{cha:chart-api:omnetpp.scave.chart:get-property}

\begin{flushleft}
\ttt{get\_property(key)}
\end{flushleft}

\par Returns the value of a single property of the chart, or \ttt{None} if there is
no property with the given name (key) set on the chart.

\subsubsection{get\_name()}
\label{cha:chart-api:omnetpp.scave.chart:get-name}

\begin{flushleft}
\ttt{get\_name()}
\end{flushleft}

\par Returns the name of the chart as a string.

\subsubsection{get\_chart\_type()}
\label{cha:chart-api:omnetpp.scave.chart:get-chart-type}

\begin{flushleft}
\ttt{get\_chart\_type()}
\end{flushleft}

\par Returns the chart type, one of the strings "bar"/"histogram"/"line"/"matplotlib"

\subsubsection{is\_native\_chart()}
\label{cha:chart-api:omnetpp.scave.chart:is-native-chart}

\begin{flushleft}
\ttt{is\_native\_chart()}
\end{flushleft}

\par Returns True if this chart uses the IDE's built-in plotting widgets.

\subsubsection{set\_suggested\_chart\_name()}
\label{cha:chart-api:omnetpp.scave.chart:set-suggested-chart-name}

\begin{flushleft}
\ttt{set\_suggested\_chart\_name(name)}
\end{flushleft}

\par Sets a proposed name for the chart. The IDE may offer this name to the user
when saving the chart.

\subsection{Module omnetpp.scave.plot}
\label{cha:chart-api:omnetpp.scave.plot}

\par This module is the interface for displaying data using the IDE's native
(non-Matplotlib) plotting widgets. The API is intentionally very close to
\ttt{matplotlib.pyplot}: most functions and the parameters they accept are a
subset of \ttt{pyplot}'s. The promise is that a chart script written with this
API is very easy to switch over to Matplotlib: usually, just importing
\ttt{matplotlib.pyplot} as \ttt{plot} (instead of importing this package) is
sufficient. Also the other way round: if a chart script uses only this
subset of \ttt{pyplot}'s API, it can be easily switched over to plot with the
IDE's native widgets.

\par When the API is used outside the context of a native plotting widget
(such as during the run of \ttt{opp\_charttool}, or in IDE during image export),
the functions are emulated with Matplotlib.

\subsubsection{is\_native\_plot()}
\label{cha:chart-api:omnetpp.scave.plot:is-native-plot}

\begin{flushleft}
\ttt{is\_native\_plot()}
\end{flushleft}

\par Returns True if the script is running in the context of a native plotting
widget, and False otherwise.

\subsubsection{plot()}
\label{cha:chart-api:omnetpp.scave.plot:plot}

\begin{flushleft}
\ttt{plot(xs, ys, key=None, label=None, drawstyle=None, linestyle=None, linewidth=None, color=None, marker=None, markersize=None)}
\end{flushleft}

\par Plot y versus x as lines and/or markers. Call \ttt{plot} multiple times
to plot multiple sets of data.

\par Parameters:

\begin{itemize}
  \item \ttt{x}, \ttt{y} \textit{(array-like or scalar)}: The horizontal / vertical coordinates of the data points.
  \item \ttt{key} \textit{(string)}: Identifies the series in the native plot widget.
  \item \ttt{label} \textit{(string)}: Series label for the legend
  \item \ttt{drawstyle} \textit{(string)}: Matplotlib draw style ('default', 'steps', 'steps-pre', 'steps-mid', 'steps-post')
  \item \ttt{linestyle} \textit{(string)}: Matplotlib line style ('-', '--', '-.', ':', etc\}
  \item \ttt{linewidth} \textit{(float)}: Line width in pixels
  \item \ttt{color} \textit{(string)}: Matplotlib color name or abbreviation ('b' for blue, 'g' for green, etc.)
  \item \ttt{marker} \textit{(string)}: Matplotlib marker name ('.', ',', 'o', 'x', '+', etc.)
  \item \ttt{markersize} \textit{(float)}: Size of markers in pixels.

\end{itemize}

\subsubsection{hist()}
\label{cha:chart-api:omnetpp.scave.plot:hist}

\begin{flushleft}
\ttt{hist(x, bins, key=None, density=False, weights=None, cumulative=False, bottom=None, histtype="stepfilled", color=None, label=None, linewidth=None, underflows=0.0, overflows=0.0, minvalue=nan, maxvalue=nan)}
\end{flushleft}

\par Make a histogram plot. This function adds one histogram the bar plot; make
multiple calls to add multiple histograms.

\par Parameters:

\begin{itemize}
  \item \ttt{x} \textit{(array-like)}: Input values.
  \item \ttt{bins} \textit{(array-like)}: Bin edges, including left edge of first bin and right edge of last bin.
  \item \ttt{key} \textit{(string)}: Identifies the series in the native plot widget.
  \item \ttt{density} \textit{(bool)}: See \ttt{mpl.hist()}.
  \item \ttt{weights} \textit{(array-like)}: Weights.
  \item \ttt{cumulative} \textit{(bool)}: See \ttt{mpl.hist()}.
  \item \ttt{bottom} \textit{(float)}: Location of the bottom baseline for bins.
  \item \ttt{histtype} \textit{(string)}: Whether to fill the area under the plot. Accepted values are 'step' and 'stepfilled'.
  \item \ttt{color} \textit{(string)}: Matplotlib color name or abbreviation ('b' for blue, 'g' for green, etc.)
  \item \ttt{label} \textit{(string)}: Series label for the legend
  \item \ttt{linewidth} \textit{(float)}: Line width in pixels
  \item \ttt{underflows}, \ttt{overflows}: Number of values / sum of weights outside the histogram bins in both directions.
  \item \ttt{minvalue}, \ttt{maxvalue}: The minimum and maximum value, or \ttt{nan} if unknown.

\end{itemize}


\par Restrictions:

\begin{enumerate}
  \item Overflow bin data (minvalue, maxvalue, underflows and overflows) is not accepted by \ttt{pyplot.hist()}.
  \item The native plot widget only accepts a precomputed histogram (using the trick documented for \ttt{pyplot.hist()})

\end{enumerate}

\subsubsection{bar()}
\label{cha:chart-api:omnetpp.scave.plot:bar}

\begin{flushleft}
\ttt{bar(x, height, width=0.8, key=None, label=None, color=None, edgecolor=None)}
\end{flushleft}

\par Make a bar plot. This function adds one series to the bar plot; make
multiple calls to add multiple series.

\par The bars are positioned at x with the given alignment. Their dimensions
are given by width and height. The vertical baseline is bottom (default 0).

\par Each of x, height, width, and bottom may either be a scalar applying to
all bars, or it may be a sequence of length N providing a separate value
for each bar.

\par Parameters:

\begin{itemize}
  \item \ttt{x} \textit{(sequence of scalars)}: The x coordinates of the bars.
  \item \ttt{height} \textit{(scalar or sequence of scalars)}: The height(s) of the bars.
  \item \ttt{width} \textit{(scalar or array-like)}: The width(s) of the bars.
  \item \ttt{key} \textit{(string)}: Identifies the series in the native plot widget.
  \item \ttt{label} \textit{(string)}: The label of the series the bars represent .
  \item \ttt{color} \textit{(string)}: The fill color of the bars.
  \item \ttt{edgecolor} \textit{(string)}: The edge color of the bars.

\end{itemize}


\par The native plot implementation has the following restrictions:

\begin{itemize}
  \item widths are automatic (parameter is ignored)
  \item x coordinates are automatic (values are ignored)
  \item height must be a sequence (cannot be a scalar)
  \item in multiple calls to bar(), the lengths of the height sequence must be
equal (i.e. all series must have the same number of values)
  \item default color is grey (Matplotlib assigns a different color to each series)

\end{itemize}

\subsubsection{set\_property()}
\label{cha:chart-api:omnetpp.scave.plot:set-property}

\begin{flushleft}
\ttt{set\_property(key, value)}
\end{flushleft}

\par Sets one property of the native plot widget to the given value. When invoked
outside the contex of a native plot widget, the function does nothing.

\par Parameters:

\begin{itemize}
  \item \ttt{key} \textit{(string)}: Name of the property.
  \item \ttt{value} \textit{(string)}: The value to set. If any other type than string is passed in, it will be converted to string.

\end{itemize}

\subsubsection{set\_properties()}
\label{cha:chart-api:omnetpp.scave.plot:set-properties}

\begin{flushleft}
\ttt{set\_properties(props)}
\end{flushleft}

\par Sets several properties of the native plot widget. It is functionally equivalent to
repeatedly calling \ttt{set\_property} with the entries of the \ttt{props} dictionary.
When invoked outside the contex of a native plot widget (TODO?), the function does nothing.

\par Parameters:

\begin{itemize}
  \item \ttt{props} \textit{(dict)}: The properties to set.

\end{itemize}

\subsubsection{get\_supported\_property\_keys()}
\label{cha:chart-api:omnetpp.scave.plot:get-supported-property-keys}

\begin{flushleft}
\ttt{get\_supported\_property\_keys()}
\end{flushleft}

\par Returns the list of property names that the native plot widget supports, such as
'Plot.Title', 'X.Axis.Max' and 'Legend.Display', among many others.

\par Note: This method has no equivalent in \ttt{pyplot}. When the script runs outside the IDE  (TODO?),
the method returns an empty list.

\subsubsection{set\_warning()}
\label{cha:chart-api:omnetpp.scave.plot:set-warning}

\begin{flushleft}
\ttt{set\_warning(warning:str)}
\end{flushleft}

\par Displays the given warning text in the plot.

\subsubsection{title()}
\label{cha:chart-api:omnetpp.scave.plot:title}

\begin{flushleft}
\ttt{title(label:str)}
\end{flushleft}

\par Sets the plot title to the given string.

\subsubsection{xlabel()}
\label{cha:chart-api:omnetpp.scave.plot:xlabel}

\begin{flushleft}
\ttt{xlabel(xlabel:str)}
\end{flushleft}

\par Sets the label of the X axis to the given string.

\subsubsection{ylabel()}
\label{cha:chart-api:omnetpp.scave.plot:ylabel}

\begin{flushleft}
\ttt{ylabel(ylabel:str)}
\end{flushleft}

\par Sets the label of the Y axis to the given string..

\subsubsection{xlim()}
\label{cha:chart-api:omnetpp.scave.plot:xlim}

\begin{flushleft}
\ttt{xlim(left=None, right=None)}
\end{flushleft}

\par Sets the limits of the X axis.

\par Parameters:

\begin{itemize}
  \item \ttt{left} \textit{(float)}: The left xlim in data coordinates. Passing None leaves the limit unchanged.
  \item \ttt{right} \textit{(float)}: The right xlim in data coordinates. Passing None leaves the limit unchanged.

\end{itemize}

\subsubsection{ylim()}
\label{cha:chart-api:omnetpp.scave.plot:ylim}

\begin{flushleft}
\ttt{ylim(bottom=None, top=None)}
\end{flushleft}

\par Sets the limits of the Y axis.

\par Parameters:

\begin{itemize}
  \item \ttt{bottom} \textit{(float)}: The bottom ylim in data coordinates. Passing None leaves the limit unchanged.
  \item \ttt{top} \textit{(float)}: The top ylim in data coordinates. Passing None leaves the limit unchanged.

\end{itemize}

\subsubsection{xscale()}
\label{cha:chart-api:omnetpp.scave.plot:xscale}

\begin{flushleft}
\ttt{xscale(value:str)}
\end{flushleft}

\par Sets the scale of the X axis. Possible values are 'linear' and 'log'.

\subsubsection{yscale()}
\label{cha:chart-api:omnetpp.scave.plot:yscale}

\begin{flushleft}
\ttt{yscale(value:str)}
\end{flushleft}

\par Sets the scale of the Y axis.

\subsubsection{xticks()}
\label{cha:chart-api:omnetpp.scave.plot:xticks}

\begin{flushleft}
\ttt{xticks(ticks=None, labels=None, rotation=0)}
\end{flushleft}

\par Sets the current tick locations and labels of the x-axis.

\par Parameters:

\begin{itemize}
  \item \ttt{ticks} \textit{(array\_like)}: A list of positions at which ticks should be placed. You can pass an empty list to disable xticks.
  \item \ttt{labels} \textit{(array\_like)}: A list of explicit labels to place at the given locs.
  \item \ttt{rotation} \textit{(float)}: Label rotation in degrees.

\end{itemize}

\subsubsection{grid()}
\label{cha:chart-api:omnetpp.scave.plot:grid}

\begin{flushleft}
\ttt{grid(b=True, which="major")}
\end{flushleft}

\par Configure the grid lines.

\par Parameters:

\begin{itemize}
  \item \ttt{b} \textit{(bool or \ttt{None})}: Whether to show the grid lines.
  \item \ttt{which} \textit{('major', 'minor' or 'both')}: The grid lines to apply the changes on.

\end{itemize}

\subsubsection{legend()}
\label{cha:chart-api:omnetpp.scave.plot:legend}

\begin{flushleft}
\ttt{legend(show=None, frameon=None, loc=None)}
\end{flushleft}

\par Place a legend on the axes.

\par Parameters:

\begin{itemize}
  \item \ttt{show} \textit{(bool or \ttt{None})}: Whether to show the legend. TODO does pyplot have this?
  \item \ttt{frameon} \textit{(bool or \ttt{None})}: Control whether the legend should be drawn on a patch (frame).
  Default is \ttt{None}, which will take the value from the resource file.
  \item \ttt{loc} \textit{(string or \ttt{None})}: The location of the legend. Possible values are
  'best', 'upper right', 'upper left', 'lower left', 'lower right', 'right',
  'center left', 'center right', 'lower center', 'upper center', 'center'
  (these are the values supported by Matplotlib), plus additionally
  'outside top left', 'outside top center', 'outside top right',
  'outside bottom left', 'outside bottom center', 'outside bottom right',
  'outside left top', 'outside left center', 'outside left bottom',
  'outside right top', 'outside right center', 'outside right bottom'.

\end{itemize}

\subsection{Module omnetpp.scave.utils}
\label{cha:chart-api:omnetpp.scave.utils}

\par A collection of utility function for data manipulation and plotting, built
on top of Pandas data frames and the \ttt{chart} and \ttt{plot} packages from \ttt{omnetpp.scave}.
Functions in this module have been written largely to the needs of the
chart templates that ship with the IDE.

\par There are some functions which are (almost) mandatory elements in a chart script.
These are the following.

\par If you want style settings in the chart dialog to take effect:

\begin{itemize}
  \item \ttt{preconfigure\_plot()}
  \item \ttt{postconfigure\_plot()}

\end{itemize}


\par If you want image/data export to work:

\begin{itemize}
  \item \ttt{export\_image\_if\_needed()}
  \item \ttt{export\_data\_if\_needed()}

\end{itemize}

\subsubsection{make\_legend\_label()}
\label{cha:chart-api:omnetpp.scave.utils:make-legend-label}

\begin{flushleft}
\ttt{make\_legend\_label(legend\_cols, row)}
\end{flushleft}

\par Produces a reasonably good label text (to be used in a chart legend) for a result row from
a DataFrame, given a list of selected columns as returned by \ttt{extract\_label\_columns()}.

\par The normal behavior is to concatenate a string from selected (by \ttt{legend\_cols}) elements
of \ttt{row}. If there is a \ttt{legend} column in \ttt{row}, that one is used and \ttt{legend\_cols} is
ignored. If there is a \ttt{comment} column in \ttt{row}, its contents will be appended in parens.

\par Parameters:

\begin{itemize}
  \item \ttt{legend\_cols} \textit{(list of strings)}: The names of columns chosen for the legend.
  \item \ttt{row} \textit{(named tuple)}: The row from the dataframe.

\end{itemize}

\subsubsection{plot\_bars()}
\label{cha:chart-api:omnetpp.scave.utils:plot-bars}

\begin{flushleft}
\ttt{plot\_bars(df, props, variable\_name=None, errors\_df=None)}
\end{flushleft}

\par Creates a bar plot from the dataframe, with styling and additional input
coming from the properties. Each column in the dataframe defines a series.

\par Column names serve as labels for the legend. Group names (displayed on the
x axis) are taken from the row index. The names of the two indices also appear
in the legend and as x axis label. (This is useful if column and group names
are values of a variable, and the index name contains the name of the variable.)
The name of the variable represented by the values can be passed in as
the \ttt{variable\_name} argument (as it is not present in the dataframe); if so,
it will become the y axis label.

\par Error bars can be drawn by providing an extra dataframe of identical
dimensions as the main one. Error bars will protrude by the values in the
errors dataframe both up and down (i.e. range is 2x error).

\par Colors are assigned automatically. The \ttt{cycle\_seed} property allows you
to select other combinations if the default one is not suitable.

\par Parameters:

\begin{itemize}
  \item \ttt{df}: the dataframe
  \item \ttt{props} \textit{(dict)}: the properties
  \item \ttt{variable\_name} \textit{(string)}: The name of the variable represented by the values.
  \item \ttt{errors\_df}: dataframe with the errors (in y axis units)

\end{itemize}


\par Notable properties that affect the plot:

\begin{itemize}
  \item \ttt{baseline}: The y value at which the x axis is drawn.
  \item \ttt{bar\_placement}: Selects the arrangement of bars: aligned, overlap, stacked, etc.
  \item \ttt{xlabel\_rotation}: Amount of counter-clockwise rotation of x axis labels a.k.a. group names, in degrees.
  \item \ttt{title}: Plot title (autocomputed if missing).
  \item \ttt{cycle\_seed}: Alters the sequence in which colors are assigned to series.

\end{itemize}

\subsubsection{plot\_vectors()}
\label{cha:chart-api:omnetpp.scave.utils:plot-vectors}

\begin{flushleft}
\ttt{plot\_vectors(df, props, legend\_func=make\_legend\_label)}
\end{flushleft}

\par Creates a line plot from the dataframe, with styling and additional input
coming from the properties. Each row in the dataframe defines a series.

\par Colors and markers are assigned automatically. The \ttt{cycle\_seed} property
allows you to select other combinations if the default one is not suitable.

\par The legend is normally computed automatically from columns which best
differentiate among the series. There are also multiple ways to influence
the labels: the \ttt{legend\_labels} property, the \ttt{comment} and \ttt{legend} dataframe
columns, and also the \ttt{legend\_func} argument.

\par Parameters:

\begin{itemize}
  \item \ttt{df}: the dataframe
  \item \ttt{props} \textit{(dict)}: the properties
  \item \ttt{legend\_func}: the function to produce custom legend labels

\end{itemize}


\par Columns of the dataframe:

\begin{itemize}
  \item \ttt{vectime}, \ttt{vecvalue} \textit{(Numpy \ttt{ndarray}'s of matching sizes)}: the x and y coordinates for the plot
  \item \ttt{interpolationmode} \textit{(str, optional)}: this column normally comes from a result attribute, and determines how the points will be connected
  \item \ttt{legend} \textit{(optional)}: legend label for the series; if missing, legend labels are derived from other columns
  \item \ttt{name}, \ttt{title}, \ttt{module}, etc. \textit{(optional)}: provide input for the legend
  \item \ttt{comment} \textit{(optional)}: will be appended to the legend labels

\end{itemize}


\par Notable properties that affect the plot:

\begin{itemize}
  \item \ttt{title}: plot title (autocomputed if missing)
  \item \ttt{legend\_labels}: selects whether to prefer the \ttt{name} or the \ttt{title} column for the legend
  \item \ttt{drawstyle}: Matplotlib draw style; if present, it overrides the draw style derived from \ttt{interpolationmode}.
  \item \ttt{linestyle}, \ttt{linecolor}, \ttt{linewidth}, \ttt{marker}, \ttt{markersize}: styling
  \item \ttt{cycle\_seed}: Alters the sequence in which colors and markers are assigned to series.

\end{itemize}

\subsubsection{plot\_histograms()}
\label{cha:chart-api:omnetpp.scave.utils:plot-histograms}

\begin{flushleft}
\ttt{plot\_histograms(df, props, legend\_func=make\_legend\_label)}
\end{flushleft}

\par Creates a histogram plot from the dataframe, with styling and additional input
coming from the properties. Each row in the dataframe defines a histogram.

\par Colors are assigned automatically.  The \ttt{cycle\_seed} property allows you to
select other combinations if the default one is not suitable.

\par The legend is normally computed automatically from columns which best
differentiate among the histograms. There also are multiple ways to influence
the labels: the \ttt{legend\_labels} property, the \ttt{comment} and \ttt{legend} dataframe
columns, and also the \ttt{legend\_func} argument.

\par Parameters:

\begin{itemize}
  \item \ttt{df}: The dataframe.
  \item \ttt{props} \textit{(dict)}: The properties.
  \item \ttt{legend\_func} \textit{(function)}: The function to produce custom legend labels.
 See \ttt{utils.make\_legend\_label()} for prototype and semantics.

\end{itemize}


\par Columns of the dataframe:

\begin{itemize}
  \item \ttt{binedges}, \ttt{binvalues} \textit{(array-like, \ttt{len(binedges)==len(binvalues)+1})}:
 The bin edges and the bin values (count or sum of weights) for the histogram.
  \item \ttt{min}, \ttt{max}, \ttt{underflows}, \ttt{overflows} \textit{(float, optional)}: The minimum/maximum
 values, and the bin values for the underflow/overflow bins. These four columns
 must either be all present or all absent from the dataframe.
  \item \ttt{legend} \textit{(string, optional)}: Legend label for the series. If missing,
 legend labels are derived from other columns.
  \item \ttt{name}, \ttt{title}, \ttt{module}, etc. \textit{(optional)}: Provide input for the legend.
  \item \ttt{comment} \textit{(string, optional)}: will be appended to the legend labels.

\end{itemize}


\par Notable properties that affect the plot:

\begin{itemize}
  \item \ttt{normalize} \textit{(bool)}: If true, normalize the sum of the bin values to 1. If
\ttt{normalize} is true (and \ttt{cumulative} is false), the probability density
 function (PDF) will be displayed.
  \item \ttt{cumulative} \textit{(bool)}: If true, show each bin as the sum of the previous bin
 values plus itself. If both \ttt{normalize} and \ttt{cumulative} are true, that
 results in the cumulative density function (CDF) being displayed.
  \item \ttt{show\_overflows} \textit{(bool)}: If true, show the underflow/overflow bins.
  \item \ttt{title}: Plot title (autocomputed if missing).
  \item \ttt{legend\_labels}: Selects whether to prefer the \ttt{name} or the \ttt{title} column for the legend.
  \item \ttt{drawstyle}: Selects whether to fill the area below the histogram line.
  \item \ttt{linestyle}, \ttt{linecolor}, \ttt{linewidth}: Styling.
  \item \ttt{cycle\_seed}: Alters the sequence in which colors and markers are assigned to series.

\end{itemize}

\subsubsection{customized\_box\_plot()}
\label{cha:chart-api:omnetpp.scave.utils:customized-box-plot}

\begin{flushleft}
\ttt{customized\_box\_plot(percentiles, labels=None, axes=None, redraw=True, *args, **kwargs)}
\end{flushleft}

\par Generates a customized box-and-whiskers plot based on explicitly specified
percentile values. This method is necessary because \ttt{pyplot.boxplot()} insists
on computing the stats from the raw data (which we often don't have) itself.

\par The data are in the \ttt{percentiles} argument, which should be list of tuples.
One box will be drawn for each tuple. Each tuple contains 6 elements (or 5,
because the last one is optional):

\par (\textit{q1\_start}, \textit{q2\_start}, \textit{q3\_start}, \textit{q4\_start}, \textit{q4\_end}, \textit{fliers})

\par The first five elements have following meaning:

\begin{itemize}
  \item \textit{q1\_start}: y coord of bottom whisker cap
  \item \textit{q2\_start}: y coord of bottom of the box
  \item \textit{q3\_start}: y coord of median mark
  \item \textit{q4\_start}: y coord of top of the box
  \item \textit{q4\_end}: y coord of top whisker cap

\end{itemize}


\par The last element, \textit{fliers}, is a list, containing the values of the
outlier points.

\par x coords of the box-and-whiskers plots are automatic.

\par Parameters:

\begin{itemize}
  \item \ttt{percentiles}: The list of tuples.
  \item \ttt{labels}: If provided, the legend labels for the boxes.
  \item \ttt{axes}: The axes object of the plot.
  \item \ttt{redraw}: If False, redraw is deferred.
  \item \ttt{args}, \ttt{kwargs}: Passed to \ttt{axes.boxplot()}.

\end{itemize}

\subsubsection{preconfigure\_plot()}
\label{cha:chart-api:omnetpp.scave.utils:preconfigure-plot}

\begin{flushleft}
\ttt{preconfigure\_plot(props)}
\end{flushleft}

\par Configures the plot according to the given properties, which normally
get their values from setting in the "Configure Chart" dialog.
Calling this function before plotting was performed should be a standard
part of chart scripts.

\par A partial list of properties taken into account for native plots:

\begin{itemize}
  \item property keys understood by the plot widget, see \ttt{plot.get\_supported\_property\_keys()}
  \item properties listed in the \ttt{plot.properties} property

\end{itemize}


\par And for Matplotlib plots:

\begin{itemize}
  \item \ttt{plt.style}
  \item properties listed in the \ttt{matplotlibrc} property
  \item properties prefixed with \ttt{matplotlibrc.}

\end{itemize}


\par Parameters:

\begin{itemize}
  \item \ttt{props} \textit{(dict)}: the properties

\end{itemize}

\subsubsection{postconfigure\_plot()}
\label{cha:chart-api:omnetpp.scave.utils:postconfigure-plot}

\begin{flushleft}
\ttt{postconfigure\_plot(props)}
\end{flushleft}

\par Configures the plot according to the given properties, which normally
get their values from setting in the "Configure Chart" dialog.
Calling this function after plotting was performed should be a standard part
of chart scripts.

\par A partial list of properties taken into account:

\begin{itemize}
  \item \ttt{yaxis\_title}, \ttt{yaxis\_title}, \ttt{xaxis\_min},  \ttt{xaxis\_max}, \ttt{yaxis\_min},
\ttt{yaxis\_max}, \ttt{xaxis\_log}, \ttt{yaxis\_log}, \ttt{legend\_show}, \ttt{legend\_border},
\ttt{legend\_placement}, \ttt{grid\_show}, \ttt{grid\_density}

\end{itemize}


\par Parameters:

\begin{itemize}
  \item \ttt{props} \textit{(dict)}: the properties

\end{itemize}

\subsubsection{export\_image\_if\_needed()}
\label{cha:chart-api:omnetpp.scave.utils:export-image-if-needed}

\begin{flushleft}
\ttt{export\_image\_if\_needed(props)}
\end{flushleft}

\par If a certain property is set, save the plot in the selected image format.
Calling this function should be a standard part of chart scripts, as it is what
makes the "Export image" functionality of the IDE and \ttt{opp\_charttool} work.

\par Note that for export, even IDE-native charts are rendered using Matplotlib.

\par The properties that are taken into account:

\begin{itemize}
  \item \ttt{export\_image} \textit{(boolean)}: Controls whether to perform the exporting. This is
 normally \ttt{false}, and only set to \ttt{true} by the IDE or opp\_charttool when
 image export is requested.
  \item \ttt{image\_export\_format}: The default is SVG. Accepted formats (and their names) are the ones supported by Matplotlib.
  \item \ttt{image\_export\_folder}: The folder in which the image file is to be created.
  \item \ttt{image\_export\_filename}: The output file name. If missing or empty, a
 sanitized version of the chart name is used.
  \item \ttt{image\_export\_width}: Image width in inches (default: 6")
  \item \ttt{image\_export\_height}: Image height in inches (default: 4")
  \item \ttt{image\_export\_dpi}: DPI setting, default 96. For raster image formats, the
 image dimensions are produced as width (or height) times dpi.

\end{itemize}


\par Note that these properties come from two sources to allow meaningful batch
export. \ttt{export\_image}, \ttt{image\_export\_format}, \ttt{image\_export\_folder} and
\ttt{image\_export\_dpi} come from the export dialog because they are common
to all charts, while \ttt{image\_export\_filename}, \ttt{image\_export\_width} and
\ttt{image\_export\_height} come from the chart properties because they are
specific to each chart. Note that \ttt{image\_export\_dpi} is used for controlling
the resolution (for raster image formats) while letting charts maintain
their own aspect ratio and relative sizes.

\par Parameters:

\begin{itemize}
  \item \ttt{props} \textit{(dict)}: the properties

\end{itemize}

\subsubsection{export\_data\_if\_needed()}
\label{cha:chart-api:omnetpp.scave.utils:export-data-if-needed}

\begin{flushleft}
\ttt{export\_data\_if\_needed(df, props)}
\end{flushleft}

\par If a certain property is set, save the dataframe in CSV format.
Calling this function should be a standard part of chart scripts, as it is what
makes the "Export data" functionality of the IDE and \ttt{opp\_charttool} work.

\par The properties that are taken into account:

\begin{itemize}
  \item \ttt{export\_data} \textit{(boolean)}: Controls whether to perform the exporting. This is
 normally \ttt{false}, and only set to \ttt{true} by the IDE or opp\_charttool when
 data export is requested.
  \item \ttt{data\_export\_folder}: The folder in which the CSV file is to be created.
  \item \ttt{data\_export\_filename}: The output file name. If missing or empty, a
 sanitized version of the chart name is used.

\end{itemize}


\par Note that these properties come from two sources to allow meaningful batch
export. \ttt{export\_data} and \ttt{image\_export\_folder} come from the export dialog
because they are common to all charts, and \ttt{image\_export\_filename} comes
from the chart properties because it is specific to each chart.

\par Parameters:

\begin{itemize}
  \item \ttt{df}: the dataframe to save
  \item \ttt{props} \textit{(dict)}: the properties

\end{itemize}

\subsubsection{confidence\_interval()}
\label{cha:chart-api:omnetpp.scave.utils:confidence-interval}

\begin{flushleft}
\ttt{confidence\_interval(alpha, data)}
\end{flushleft}

\par Returns the half-length of the confidence interval of the mean of \ttt{data}, assuming
normal distribution, for the given confidence level \ttt{alpha}.

\par Parameters:

\begin{itemize}
  \item \ttt{alpha} \textit{(float)}: Confidence level, must be in the [0..1] range.
  \item \ttt{data} \textit{(array-like)}: An array containing the values.

\end{itemize}

\subsubsection{perform\_vector\_ops()}
\label{cha:chart-api:omnetpp.scave.utils:perform-vector-ops}

\begin{flushleft}
\ttt{perform\_vector\_ops(df, operations:str)}
\end{flushleft}

\par Performs the given vector operations on the dataframe, and returns the
resulting dataframe. Vector operations primarily affect the \ttt{vectime}
and \ttt{vecvalue} columns of the dataframe, which are expected to contain
\ttt{ndarray}'s of matching lengths.

\par \ttt{operations} is a multiline string where each line denotes an operation;
they are applied in sequence. The syntax of one operation is:

\par [(\ttt{compute}|\ttt{apply}) \ttt{:} ] \textit{opname} [ \ttt{(} \textit{arglist} \ttt{)} ] [ \ttt{\#} \textit{comment} ]

\par Blank lines and lines only containing a comment are also accepted.

\par \textit{opname} is the name of the function, optionally qualified with its package name.
If the package name is omitted, \ttt{omnetpp.scave.vectorops} is assumed.

\par \ttt{compute} and \ttt{apply} specify whether the newly computed vectors will replace
the input row in the DataFrame (\textit{apply}) or added as extra lines (\textit{compute}).
The default is \textit{apply}.

\par See the contents of the \ttt{omnetpp.scave.vectorops} package for more information.

\subsubsection{set\_plot\_title()}
\label{cha:chart-api:omnetpp.scave.utils:set-plot-title}

\begin{flushleft}
\ttt{set\_plot\_title(title, suggested\_chart\_name=None)}
\end{flushleft}

\par Sets the plot title. It also sets the suggested chart name (the name that
the IDE offers when adding a temporary chart to the Analysis file.)

\subsubsection{extract\_label\_columns()}
\label{cha:chart-api:omnetpp.scave.utils:extract-label-columns}

\begin{flushleft}
\ttt{extract\_label\_columns(df, preferred\_legend\_column="title")}
\end{flushleft}

\par Utility function to make a reasonable guess as to which column of
the given DataFrame is most suitable to act as a chart title and
which ones can be used as legend labels.

\par Ideally a "title column" should be one in which all lines have the same
value, and can be reasonably used as a title. Some often used candidates
are: \ttt{title}, \ttt{name}, and \ttt{module}.

\par Label columns should be a minimal set of columns whose corresponding
value tuples uniquely identify every line in the DataFrame. These will
primarily be iteration variables and run attributes.

\par Returns:

\par A pair of a string and a list; the first value is the name of the
"title" column, and the second one is a list of pairs, each
containing the index and the name of a "label" column.

\par Example: \ttt{('title', [(8, 'numHosts'), (7, 'iaMean')])}

\subsubsection{make\_chart\_title()}
\label{cha:chart-api:omnetpp.scave.utils:make-chart-title}

\begin{flushleft}
\ttt{make\_chart\_title(df, title\_col, legend\_cols)}
\end{flushleft}

\par Produces a reasonably good chart title text from a result DataFrame, given a selected "title"
column, and a list of selected "legend" columns as returned by \ttt{extract\_label\_columns()}.

\subsubsection{pick\_two\_columns()}
\label{cha:chart-api:omnetpp.scave.utils:pick-two-columns}

\begin{flushleft}
\ttt{pick\_two\_columns(df)}
\end{flushleft}

\par Choose two columns from the dataframe which best partitions the rows
of the dataframe, and returns their names as a pair. Returns (\ttt{None}, \ttt{None})
if no such pair was found. This method is useful for creating e.g. a bar plot.

\subsubsection{assert\_columns\_exist()}
\label{cha:chart-api:omnetpp.scave.utils:assert-columns-exist}

\begin{flushleft}
\ttt{assert\_columns\_exist(df, cols, message="Expected column missing from DataFrame")}
\end{flushleft}

\par Ensures that the dataframe contains the given columns. If any of them are missing,
the function raises an error with the given message.

\par Parameters:

\begin{itemize}
  \item \ttt{cols} \textit{(list of strings)}: Column names to check.

\end{itemize}

\subsubsection{to\_numeric()}
\label{cha:chart-api:omnetpp.scave.utils:to-numeric}

\begin{flushleft}
\ttt{to\_numeric(df, columns=None, errors="ignore", downcast=None)}
\end{flushleft}

\par Convenience function. Runs \ttt{pandas.to\_numeric} on the given
(or all) columns of \ttt{df}. If any of the given columns doesn't
exist, throws an error.

\par Parameters:

\begin{itemize}
  \item \ttt{df} \textit{(DataFrame)}: The DataFrame to operate on
  \item \ttt{columns} \textit{(list of strings)}: The list of column names to convert.
If not given, all columns will be converted.
  \item \ttt{errors}, \ttt{downcast} \textit{(string)}: Will be passed to \ttt{pandas.to\_numeric()}

\end{itemize}

\subsubsection{parse\_rcparams()}
\label{cha:chart-api:omnetpp.scave.utils:parse-rcparams}

\begin{flushleft}
\ttt{parse\_rcparams(rc\_content)}
\end{flushleft}

\par Accepts a multiline string that contains rc file content in Matplotlib's
RcParams syntax, and returns its contents as a dictionary. Parse errors
and duplicate keys are reported via exceptions.

\subsubsection{make\_fancy\_xticklabels()}
\label{cha:chart-api:omnetpp.scave.utils:make-fancy-xticklabels}

\begin{flushleft}
\ttt{make\_fancy\_xticklabels(ax)}
\end{flushleft}

\par Only useful for Matplotlib plots. It causes the x tick labels to be rotated
by the minimum amount necessary so that they don't overlap. Note that the
necessary amount of rotation typically depends on the horizontal zoom level.

\subsubsection{get\_names\_for\_title()}
\label{cha:chart-api:omnetpp.scave.utils:get-names-for-title}

\begin{flushleft}
\ttt{get\_names\_for\_title(df, props)}
\end{flushleft}

\par Returns unique values from the \ttt{title} or \ttt{name} column, depending on the
value of the \ttt{legend\_labels} property in \ttt{props}. This function is useful
for producing input for the plot title.

\subsubsection{split()}
\label{cha:chart-api:omnetpp.scave.utils:split}

\begin{flushleft}
\ttt{split(s, sep=",")}
\end{flushleft}

\par Split a string with the given separator (by default with comma), trim
the surrounding whitespace from the items, and return the result as a
list. Returns an empty list for an empty or all-whitespace input string.
(Note that in contrast, \ttt{s.split(',')} will return an empty array,
even for \ttt{s=''}.)

\subsection{Module omnetpp.scave.vectorops}
\label{cha:chart-api:omnetpp.scave.vectorops}

\par Contains operations that can be applied to vectors.

\par In the IDE, operations can be applied to vectors on a vector chart by means
of the plot's context menu and by editing the \textit{Vector Operations} field in
the chart configuration dialog.

\par Every vector operation is implemented as a function. The notation used
in the documentation of the individual functions is:

\begin{itemize}
  \item \textit{y[k]}: The kth value in the input
  \item \textit{t[k]}: The kth timestamp in the input
  \item \textit{yout[k]}: The kth value in the output
  \item \textit{tout[k]}: The kth timestamp in the output

\end{itemize}


\par A vector operation function accepts a DataFrame row as the first positional
argument, and optionally additional arguments specific to its operation.
When the function is invoked, the row will contain a \ttt{vectime} and a \ttt{vecvalue}
column (both containing NumPy \ttt{ndarray}'s) that are the input of the operation.
The function should return a similar row, with updated \ttt{vectime} and a \ttt{vecvalue}
columns.

\par Additionally, the operation may update the \ttt{name} and \ttt{title} columns (provided
they exist) to reflect the processing in the name. For example, an operation
that computes \textit{mean} may return \ttt{mean(\%s)} as name and \ttt{Mean of \%s} as title
(where \ttt{\%s} indicates the original name/title).

\par The \ttt{aggregate()} and \ttt{compute()} functions are special. They receive a DataFrame
instead of a row in the first argument, and return new DataFrame with the result.

\par Vector operations can be applied to a DataFrame using \ttt{utils.perform\_vector\_ops(df,ops)}.
\ttt{ops} is a multiline string where each line denotes an operation; they are
applied in sequence. The syntax of one operation is:

\par [(\ttt{compute}|\ttt{apply}) \ttt{:} ] \textit{opname} [ \ttt{(} \textit{arglist} \ttt{)} ] [ \ttt{\#} \textit{comment} ]

\par \textit{opname} is the name of the function, optionally qualified with its package name.
If the package name is omitted, \ttt{omnetpp.scave.vectorops} is assumed.

\par \ttt{compute} and \ttt{apply} specify whether the newly computed vectors will replace
the input row in the DataFrame (\textit{apply}) or added as extra lines (\textit{compute}).
The default is \textit{apply}.

\par To define a new vector operation, define a function that fulfills the above
interface (e.g. in the chart script), and add it to the \ttt{omnetpp.scave.vectorops}
package.
\begin{filelisting}
def foo(r, args):
    ...
from omnetpp.scave import vectorops
vectorops.foo = foo
\end{filelisting}

\subsubsection{perform\_vector\_ops()}
\label{cha:chart-api:omnetpp.scave.vectorops:perform-vector-ops}

\begin{flushleft}
\ttt{perform\_vector\_ops(df, operations:str)}
\end{flushleft}



\subsubsection{aggregate()}
\label{cha:chart-api:omnetpp.scave.vectorops:aggregate}

\begin{flushleft}
\ttt{aggregate(df, function="average")}
\end{flushleft}

\par Aggregates several vectors into a single one, aggregating the
y values \textit{at the same time coordinate} with the specified function.

\subsubsection{merge()}
\label{cha:chart-api:omnetpp.scave.vectorops:merge}

\begin{flushleft}
\ttt{merge(df)}
\end{flushleft}

\par Merges several series into a single one, maintaining increasing
time order in the output.

\subsubsection{mean()}
\label{cha:chart-api:omnetpp.scave.vectorops:mean}

\begin{flushleft}
\ttt{mean(r)}
\end{flushleft}

\par Computes mean on (0,t): yout[k] = sum(y[i], i=0..k) / (k+1).

\subsubsection{sum()}
\label{cha:chart-api:omnetpp.scave.vectorops:sum}

\begin{flushleft}
\ttt{sum(r)}
\end{flushleft}

\par Sums up values: yout[k] = sum(y[i], i=0..k)

\subsubsection{add()}
\label{cha:chart-api:omnetpp.scave.vectorops:add}

\begin{flushleft}
\ttt{add(r, c)}
\end{flushleft}

\par Adds a constant to the input: yout[k] = y[k] + c

\subsubsection{compare()}
\label{cha:chart-api:omnetpp.scave.vectorops:compare}

\begin{flushleft}
\ttt{compare(r, threshold, less=None, equal=None, greater=None)}
\end{flushleft}

\par Compares value against a threshold, and optionally replaces it with a constant.
yout[k] = if y[k] < threshold and less != None then less;
     else if y[k] == threshold and equal != None then equal;
     else if y[k] > threshold and greater != None then greater;
     else y[k]

\subsubsection{crop()}
\label{cha:chart-api:omnetpp.scave.vectorops:crop}

\begin{flushleft}
\ttt{crop(r, t1, t2)}
\end{flushleft}

\par Discards values outside the [t1, t2] interval

\subsubsection{difference()}
\label{cha:chart-api:omnetpp.scave.vectorops:difference}

\begin{flushleft}
\ttt{difference(r)}
\end{flushleft}

\par Subtracts the previous value from every value: yout[k] = y[k] - y[k-1]

\subsubsection{diffquot()}
\label{cha:chart-api:omnetpp.scave.vectorops:diffquot}

\begin{flushleft}
\ttt{diffquot(r)}
\end{flushleft}

\par Calculates the difference quotient of every value and the subsequent one:
yout[k] = (y[k+1]-y[k]) / (t[k+1]-t[k])

\subsubsection{divide\_by()}
\label{cha:chart-api:omnetpp.scave.vectorops:divide-by}

\begin{flushleft}
\ttt{divide\_by(r, a)}
\end{flushleft}

\par Divides input by a constant: yout[k] = y[k] / a

\subsubsection{divtime()}
\label{cha:chart-api:omnetpp.scave.vectorops:divtime}

\begin{flushleft}
\ttt{divtime(r)}
\end{flushleft}

\par Divides input by the current time: yout[k] = y[k] / t[k]

\subsubsection{expression()}
\label{cha:chart-api:omnetpp.scave.vectorops:expression}

\begin{flushleft}
\ttt{expression(r, expression, as\_time=False)}
\end{flushleft}

\par Replaces the value with the result of evaluating the Python arithmetic expression
given as a string: yout[k] = eval(expression). The expression may use
the following variables: \ttt{t}, \ttt{y}, \ttt{tprev}, \ttt{yprev}, \ttt{tnext}, \ttt{ynext}, \ttt{k}, \ttt{n}
which stand for t[k], y[k], t[k-1], y[k-1], t[k+1] and y[k+1], k, and the
size of vector, respectively.

\par If \ttt{as\_time} is \ttt{True}, the result will be assigned to the time variable
instead of the value variable.

\par Note that for efficiency, the expression will be evaluated only once,
with the variables being \ttt{np.ndarray} instances instead of scalar \ttt{float} values.
Thus, the result is computed using vector operations instead of looping
through all vector indices in Python. Expression syntax remains the usual.
Most Numpy mathematical functions can be used without module prefix; other
Numpy functions can be used by prefixing them with \ttt{np.}.

\par Examples: \ttt{2*y+0.5}, \ttt{abs(floor(y))}, \ttt{(y-yprev)/(t-tprev)}, \ttt{fmin(yprev,ynext)},
\ttt{cumsum(y)}, \ttt{nan\_to\_num(y)}

\subsubsection{integrate()}
\label{cha:chart-api:omnetpp.scave.vectorops:integrate}

\begin{flushleft}
\ttt{integrate(r, interpolation="sample-hold")}
\end{flushleft}

\par Integrates the input as a step function (sample-hold or backward-sample-hold) or with linear interpolation

\subsubsection{lineartrend()}
\label{cha:chart-api:omnetpp.scave.vectorops:lineartrend}

\begin{flushleft}
\ttt{lineartrend(r, a)}
\end{flushleft}

\par Adds a linear component to input series: yout[k] = y[k] + a * t[k]

\subsubsection{modulo()}
\label{cha:chart-api:omnetpp.scave.vectorops:modulo}

\begin{flushleft}
\ttt{modulo(r, m)}
\end{flushleft}

\par Computes input modulo a constant: yout[k] = y[k] \% m

\subsubsection{movingavg()}
\label{cha:chart-api:omnetpp.scave.vectorops:movingavg}

\begin{flushleft}
\ttt{movingavg(r, alpha)}
\end{flushleft}

\par Applies the exponentially weighted moving average filter:
yout[k] = yout[k-1] + alpha * (y[k]-yout[k-1])

\subsubsection{multiply\_by()}
\label{cha:chart-api:omnetpp.scave.vectorops:multiply-by}

\begin{flushleft}
\ttt{multiply\_by(r, a)}
\end{flushleft}

\par Multiplies input by a constant: yout[k] = a * y[k]

\subsubsection{removerepeats()}
\label{cha:chart-api:omnetpp.scave.vectorops:removerepeats}

\begin{flushleft}
\ttt{removerepeats(r)}
\end{flushleft}

\par Removes repeated y values

\subsubsection{slidingwinavg()}
\label{cha:chart-api:omnetpp.scave.vectorops:slidingwinavg}

\begin{flushleft}
\ttt{slidingwinavg(r, window\_size, min\_samples=None)}
\end{flushleft}

\par Replaces every value with the mean of values in the window:
yout[k] = sum(y[i], i=(k-winsize+1)..k) / winsize
If min\_samples is also given, allows each window to have only that many
valid (not missing [at the ends], and not NaN) samples in each window.

\subsubsection{subtractfirstval()}
\label{cha:chart-api:omnetpp.scave.vectorops:subtractfirstval}

\begin{flushleft}
\ttt{subtractfirstval(r)}
\end{flushleft}

\par Subtract the first value from every subsequent values: yout[k] = y[k] - y[0]

\subsubsection{timeavg()}
\label{cha:chart-api:omnetpp.scave.vectorops:timeavg}

\begin{flushleft}
\ttt{timeavg(r, interpolation)}
\end{flushleft}

\par Calculates the time average of the input (integral divided by time)

\subsubsection{timediff()}
\label{cha:chart-api:omnetpp.scave.vectorops:timediff}

\begin{flushleft}
\ttt{timediff(r)}
\end{flushleft}

\par Subtracts the previous value's timestamp from every timestamp:
tout[k] = t[k] - t[k-1]

\subsubsection{timeshift()}
\label{cha:chart-api:omnetpp.scave.vectorops:timeshift}

\begin{flushleft}
\ttt{timeshift(r, dt)}
\end{flushleft}

\par Shifts the input series in time by a constant: tout[k] = t[k] + dt

\subsubsection{timetoserial()}
\label{cha:chart-api:omnetpp.scave.vectorops:timetoserial}

\begin{flushleft}
\ttt{timetoserial(r)}
\end{flushleft}

\par Replaces time values with their index: tout[k] = k

\subsubsection{timewinavg()}
\label{cha:chart-api:omnetpp.scave.vectorops:timewinavg}

\begin{flushleft}
\ttt{timewinavg(r, window\_size=1)}
\end{flushleft}

\par Calculates time average: replaces input values in every 'windowSize' interval with their mean:
tout[k] = k \textit{ winSize,
yout[k] = average of y values in the [(k-1)}winSize, k*winSize) interval

\subsubsection{winavg()}
\label{cha:chart-api:omnetpp.scave.vectorops:winavg}

\begin{flushleft}
\ttt{winavg(r, window\_size=10)}
\end{flushleft}

\par Calculates batched average: replaces every 'winsize' input values
with their mean. Time is the time of the first value in the batch.

